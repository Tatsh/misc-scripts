#!/usr/bin/env python
# PYTHON_ARGCOMPLETE_OK
from functools import lru_cache
from os.path import basename
from typing import Mapping, Optional, Sequence, Tuple, cast
import argparse
import glob
import logging
import os
import subprocess as sp
import sys
try:
    import argcomplete
except ImportError:
    argcomplete = None



@lru_cache()
def setup_logging_stdout(name: Optional[str] = None,
                         verbose: bool = False) -> logging.Logger:
    name = name if name else basename(sys.argv[0])
    log = logging.getLogger(name)
    log.setLevel(logging.DEBUG if verbose else logging.INFO)
    channel = logging.StreamHandler(sys.stdout)
    channel.setFormatter(logging.Formatter('%(asctime)s - %(message)s'))
    channel.setLevel(logging.DEBUG if verbose else logging.INFO)
    log.addHandler(channel)
    return log


def crc_check_with_sfv(sfv_filename: str, verbose: bool = False) -> bool:
    log = setup_logging_stdout('crc_check_with_sfv', verbose=verbose)
    cwd = os.getcwd()
    sfv_dir = os.path.dirname(os.path.abspath(sfv_filename))
    args = ('cksfv', '-f', sfv_filename)
    log.debug('%s', ' '.join(args))
    os.chdir(sfv_dir)
    try:
        sp.run(args, check=True)
        return True
    except sp.CalledProcessError:
        return False
    finally:
        os.chdir(cwd)


def test_extraction(rar_filename: str, verbose: bool = False) -> bool:
    log = setup_logging_stdout('test_extraction', verbose=verbose)
    args = ['unrar', 't']
    if not verbose:
        args.append('-inul')
    args.append(rar_filename)
    log.debug('Executing: %s', ' '.join(args))
    try:
        sp.run(args, check=True)
        return True
    except sp.CalledProcessError:
        return False


def find_iso_in_rar(rar_filename: str) -> Tuple[Optional[str], Optional[int]]:
    # Find if there is an ISO within the RAR f
    work: Optional[Sequence[str]] = None
    try:
        r = sp.run(('unrar', 'l', rar_filename),
                   stdout=sp.PIPE,
                   encoding='utf-8',
                   check=True)
    except sp.CalledProcessError:
        return None, None
    for line in r.stdout.split('\n'):
        if 'iso' in line.lower():
            work = line.split()
            break
    assert work is not None, "Did not find ISO"
    # Handle spaces in ISO file name
    filename = work[4]
    if '.iso' not in filename.lower():
        filename = ''
        i = 0
        for iso in work[4:]:
            if '.iso' in iso.lower():
                filename += iso
                i += 1
                break
            filename += f'{iso} '
            i += 1
    if 'iso' not in filename.lower():
        return None, None
    work_str = work[4]
    if 'iso' in work_str.lower():
        i = 1
    return filename, int(work[i])


def unrar_cdrecord_pipe(rar_filename: str,
                        iso_filename: str,
                        tsize: int,
                        speed: int = 8,
                        device_name: Optional[str] = None,
                        verbose: bool = False) -> bool:
    log = setup_logging_stdout('unrar_cdrecord_pipe', verbose)
    unrar_args = (
        'unrar',
        'p',
        '-inul',
        rar_filename,
        iso_filename,
    )
    cdrecord_args: Tuple[str, ...] = (
        'cdrecord',
        f'speed={speed}',
        'driveropts=burnfree',
        f'tsize={tsize}',
    )
    if device_name:
        cdrecord_args += (f'dev={device_name}', )
    cdrecord_args += ('-dao', '-eject', '-')
    if verbose:
        cdrecord_args += ('-v', )
    log.debug('Command: %s | %s', ' '.join(unrar_args),
              ' '.join(cdrecord_args))
    first = sp.Popen(unrar_args, stdout=sp.PIPE, close_fds=True)
    second = sp.Popen(cdrecord_args, stdin=first.stdout, close_fds=True)
    first.stdout.close()
    second.wait()
    first.wait()
    return first.returncode == 0 and second.returncode == 0


def check_requirements(skip_crc: bool, verbose: bool = False) -> bool:
    log = setup_logging_stdout('check_requirements', verbose)
    try:
        sp.check_output(('which', 'unrar'))
        if not skip_crc:
            sp.check_output(('which', 'cksfv'))
        sp.check_output(('which', 'cdrecord'))
    except sp.CalledProcessError as e:
        command_needed = e.cmd.replace('which ', '')
        log.error('Your system is missing "%s" (or it is not in PATH)',
                  command_needed)
        apps_to_gentoo_packages = cast(
            Mapping[str, Tuple[str, ...]], {
                'unrar': ('app-arch/unrar', 'app-arch/unrar-gpl'),
                'cksfv': ('app-arch/cksfv'),
                'cdrecord': ('app-cdr/cdrtools'),
            })
        if len(apps_to_gentoo_packages[command_needed]) == 1:
            log.info(
                'If you are using Gentoo or a derivative with Gentoo\'s '
                'Portage tree, you can find "%s" in package %s',
                command_needed, apps_to_gentoo_packages[command_needed][0])
        else:
            packages = ', '.join(apps_to_gentoo_packages[command_needed])
            log.info(
                'If you are using Gentoo or a derivative with Gentoo\'s '
                'Portage tree, you can find "%s" in packages %s',
                command_needed, packages)
        return False
    return True


def main() -> int:
    parser = argparse.ArgumentParser(
        description='Burns an ISO found in a RAR file without extracting')
    parser.add_argument('-v',
                        help='enables verbose mode',
                        action='store_true',
                        dest='verbose')
    parser.add_argument('--no-crc-check',
                        help='Disable CRC check',
                        action='store_true',
                        dest='crc_test')
    parser.add_argument('--test-extraction',
                        help='Enable extraction test',
                        action='store_true',
                        dest='rar_test')
    parser.add_argument('-s',
                        type=int,
                        dest='speed',
                        help='Write speed',
                        default=8)
    parser.add_argument('-d',
                        dest='device',
                        default=None,
                        help='Device name (no argument means default)')
    parser.add_argument('rar_filename', help='Base RAR file name')
    if argcomplete:
        argcomplete.autocomplete(parser)
    args = parser.parse_args()
    rar_filename = os.path.realpath(args.rar_filename)
    log = setup_logging_stdout(verbose=args.verbose)
    if not check_requirements(args.crc_test):
        return 1
    iso, tsize = find_iso_in_rar(rar_filename)
    if not tsize:
        log.error('Unable to find ISO in RAR "%s"', args.rar_filename)
        return 1
    log.debug('Found ISO %s with tsize %d', iso, tsize)
    assert iso is not None
    if not args.crc_test:
        # See if file without .rar/.001/etc exists first
        filename_without_ext, _ = os.path.splitext(args.rar_filename)
        sfv_filenames = (
            f'{filename_without_ext}.sfv',
            f'{filename_without_ext}.SFV',
        )
        sfv_filename = None
        for name in sfv_filenames:
            if os.path.exists(name):
                sfv_filename = name
                log.debug('Found SFV file: "%s"', basename(name))
        if not sfv_filename:
            globbed = glob.glob('*.sfv')
            if globbed:
                log.debug('Found SFV file via globbing: "%s"',
                          basename(globbed[0]))
        if not sfv_filename:
            log.error('Cannot find SFV file to verify with (you can run with '
                      '--no-crc-check)')
            return 1
        if not crc_check_with_sfv(sfv_filename):
            log.error('SFV verification failed')
            return 1
    if args.rar_test:
        log.info('Testing extraction')
        if not test_extraction(rar_filename, verbose=args.verbose):
            log.error('Extraction test failed')
            return 1
        log.debug('Extraction test succeeded')
    if not unrar_cdrecord_pipe(rar_filename, iso, tsize, args.speed,
                               args.device):
        log.error('Write failed!')
        return 1
    return 0


if __name__ == '__main__':
    sys.exit(main())
