#!/usr/bin/env python
# PYTHON_ARGCOMPLETE_OK
# clean up: find . -maxdepth 1 -type d | tail -n +2 | xargs rm -fvR *.tar *.gpg
# pip install python-gnupg
from datetime import datetime
from functools import lru_cache
from os import environ as env, remove as rm
from os.path import basename, dirname, isdir, join as path_join, realpath
from shutil import rmtree
from typing import Final, Optional
import argparse
import logging
import re
import signal
import subprocess as sp
import sys
import tarfile

import argcomplete
import gnupg

LOCK_WAIT_TIMEOUT: Final[int] = 10
PG_HOST: Final[str] = 'localhost'
PG_JOBS: Final[int] = 2
PG_USER: Final[str] = 'postgres'


@lru_cache()
def setup_logging_stdout(name: Optional[str] = None, verbose: bool = False) -> logging.Logger:
    name = name if name else basename(sys.argv[0])
    log = logging.getLogger(name)
    log.setLevel(logging.DEBUG if verbose else logging.INFO)
    channel = logging.StreamHandler(sys.stdout)
    channel.setFormatter(logging.Formatter('%(message)s'))
    channel.setLevel(logging.DEBUG if verbose else logging.INFO)
    log.addHandler(channel)
    return log


def rm_if_exists(fn: str) -> bool:
    try:
        with open(fn, 'rb'):
            pass
        rm(fn)
        return True
    except IOError:
        pass
    return False


def psql(*args: str) -> str:
    return sp.run(('psql',) + args, check=True, stdout=sp.PIPE, encoding='utf-8').stdout


def pg_dump(*args: str) -> str:
    return sp.run(('pg_dump',) + args, check=True, stdout=sp.PIPE, encoding='utf-8').stdout


def main() -> int:
    parser = argparse.ArgumentParser()
    parser.add_argument('--target', '-t', help='Target directory to store in', required=True)
    parser.add_argument('--dry-run', default=False, action='store_true')
    parser.add_argument('--gpg-home', default=path_join(env['HOME'], '.gnupg'))
    parser.add_argument('--user', '-U', help='PostgreSQL user', default=PG_USER)
    parser.add_argument('--host', help='PostgreSQL host', default=PG_HOST)
    parser.add_argument('--jobs', '-j', help='Parallel jobs', default=PG_JOBS, type=int)
    parser.add_argument('--verbose', '-v', action='store_true')
    parser.add_argument('gpg_recipients', metavar='GPG_RECIPIENTS', nargs='+')
    argcomplete.autocomplete(parser)
    args = parser.parse_args()
    log = setup_logging_stdout(verbose=args.verbose)
    target_dir = realpath(args.target)
    time = datetime.today().strftime('%Y%m%d%H%M%S')
    dry_run = args.dry_run
    gpg_home = realpath(args.gpg_home)
    recipients = args.gpg_recipients

    gpg = gnupg.GPG(gnupghome=gpg_home, verbose=args.verbose, use_agent=True)
    gpg.encoding = 'utf-8'

    for i, db_name in enumerate(
            psql('-X', '-w', '-U', args.user, '-h', args.host, '-l').splitlines()):
        if i < 3:  # Skip bad lines
            continue

        name = db_name.split('|')[0].strip()
        fn = path_join(target_dir, f'{time}-{name}')

        # Cannot dump template0
        # Also skip the '(x rows)' line at the end
        if (not name or name == 'template0' or re.match(r'^\(\d+ rows\)$', name)):
            continue

        log.info('Dumping "%s" to "%s"...', name, fn)
        pg_dump_args = ('-w', '-C', '--column-inserts', '-c', '-U', args.user, '-h', args.host,
                        '-d', name, '-f', fn, '-Fd', '-j', str(
                            args.jobs), '-Z', '9', f'--lock-wait-timeout={LOCK_WAIT_TIMEOUT:d}')

        if dry_run:
            log.info('pg_dump %s', ' '.join(pg_dump_args))
            log.info('pushd %s && tar cf %s.tar %s && popd', dirname(fn), basename(fn),
                     basename(fn))
            log.info(
                'gpg --status-fd-2 --no-tty --homedir %s --use-agent'
                '--encrypt %s --armor --output %s.tar.gpg', gpg_home,
                ' '.join(f'--recipient {x}' for x in recipients), fn)
            log.info('rm %s.tar', fn)
            continue

        try:
            out = pg_dump(*pg_dump_args).strip()
        except (KeyboardInterrupt, SystemExit, sp.CalledProcessError):
            signal.signal(signal.SIGINT, signal.SIG_IGN)
            log.error('Caught interrupt. Removing "%s"', fn)
            if isdir(fn):
                rmtree(fn)
            return 1

        if out:
            log.warning(out)

        tar_fn = f'{fn}.tar'
        log.info("Tar'ing to %s", tar_fn)
        tar = tarfile.open(tar_fn, 'w')

        tar.add(fn, arcname=basename(fn))
        try:
            tar.close()
        except (KeyboardInterrupt, SystemExit):
            signal.signal(signal.SIGINT, signal.SIG_IGN)
            log.error('Caught interrupt. Removing "%s" and data', tar_fn)
            rmtree(fn)
            try:
                with open(tar_fn, 'rb'):
                    pass
                rm(tar_fn)
            except FileNotFoundError:
                pass
            return 1

        log.info('Removing "%s"', fn)
        try:
            rmtree(fn)
        except (KeyboardInterrupt, SystemExit):
            signal.signal(signal.SIGINT, signal.SIG_IGN)
            if isdir(fn):
                rmtree(fn)
            rm_if_exists(tar_fn)
            return 1

        output_fn = f'{tar_fn}.gpg'
        log.info('Encrypting "%s" to "%s"', basename(tar_fn), basename(output_fn))
        with open(tar_fn, 'rb') as fp:
            try:
                gpg.encrypt_file(fp, recipients, output=output_fn)
            except (KeyboardInterrupt, SystemExit):
                signal.signal(signal.SIGINT, signal.SIG_IGN)
                if isdir(fn):
                    rmtree(fn)
                rm_if_exists(output_fn)
                rm_if_exists(tar_fn)
                return 1

        log.info('Removing "%s"', tar_fn)
        rm(tar_fn)
    return 0


if __name__ == '__main__':
    sys.exit(main())
